<div class="page-content">
    <div class="container-fluid">
        <!-- start page title -->
        <div class="row">
            <div class="col-12">
                <div class="page-title-box d-sm-flex align-items-center justify-content-between">
                    <h4 class="mb-sm-0">Realtime Stats</h4>

                    <div class="page-title-right">
                        <ol class="breadcrumb m-0">
                            <li class="breadcrumb-item"><a href="javascript: void(0);">Armedis</a></li>
                            <li class="breadcrumb-item active">Realtime Stats</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
        <!-- end page title -->
        
        <div class="row">
            <div class="col-xl-6">
                <!-- TCP START -->
                <div class="card" id="tpsCard">
                    <div class="card-header">
                        <h4 class="card-title mb-0"></h4>
                    </div><!-- end card header -->

                    <div class="card-body">
                        <div id="area_chart_stacked" data-colors='["--vz-primary"]' class="apex-charts" dir="ltr"></div>
                    </div><!-- end card-body -->
                </div><!-- end card -->
                <!-- TCP END -->
            </div>
            <!-- end col -->
            <div class="col-xl-6">
                <!-- Hit Rate START -->
                <div class="card" id="hitRateCard">
                    <div class="card-header">
                        <h4 class="card-title mb-0"></h4>
                    </div><!-- end card header -->

                    <div class="card-body">
                        <div id="area_chart_stacked" data-colors='["--vz-primary"]' class="apex-charts" dir="ltr"></div>
                    </div><!-- end card-body -->
                </div><!-- end card -->
                <!-- Hit Rate END -->
            </div>
            <!-- end col -->
        </div>
        <!-- end row -->

        <div class="row">
            <div class="col-xl-6">
                <!-- Memory START -->
                <div class="card" id="memoryCard">
                    <div class="card-header">
                        <h4 class="card-title mb-0"></h4>
                    </div><!-- end card header -->

                    <div class="card-body">
                        <div id="area_chart_stacked" data-colors='["--vz-primary", "--vz-danger", "--vz-warning"]'
                            class="apex-charts" dir="ltr"></div>
                    </div><!-- end card-body -->
                </div><!-- end card -->
                <!-- Memory END -->
            </div>
            <!-- end col -->

            <!-- end col -->
            <div class="col-xl-6">
                <!-- Hit Rate START -->
                <div class="card" id="receivedConnectionsCard">
                    <div class="card-header">
                        <h4 class="card-title mb-0"></h4>
                    </div><!-- end card header -->

                    <div class="card-body">
                        <div id="area_chart_stacked" data-colors='["--vz-primary"]' class="apex-charts" dir="ltr"></div>
                    </div><!-- end card-body -->
                </div><!-- end card -->
                <!-- Hit Rate END -->
            </div>
            <!-- end col -->
        </div>
        <!-- end row -->

        <div class="row">
            <div class="col-xl-12">
                <!-- Analysis START -->
                <div class="card" id="redisAnalysis">
                    <div class="card-header">
                        <h5 class="card-title mb-0"></h5>
                    </div><!-- end card header -->

                    <div class="card-body">
                        <table class="table table-bordered dt-responsive nowrap table-striped align-middle"
                            style="width:100%">
                            <thead>
                                <tr></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div><!-- end card-body -->
                </div><!-- end card -->
                <!-- Analysis END -->
            </div>
            <!-- end col -->
        </div>
        <!-- end row -->

        <div class="row">
            <div class="col-xl-12">
                <!-- Instance Information START -->
                <div class="card" id="instanceInformation">
                    <div class="card-header">
                        <h5 class="card-title mb-0"></h5>
                    </div><!-- end card header -->

                    <div class="card-body">
                        <!-- <table class="table table-bordered dt-responsive nowrap table-striped align-middle" style="width:100%">
                            <thead>
                                <tr></tr>
                            </thead>
                            <tbody></tbody>
                        </table> -->
                    </div><!-- end card-body -->
                </div><!-- end card -->
                <!-- Instance Information END -->
            </div>
            <!-- end col -->
        </div>
        <!-- end row -->
    </div>
    <!-- container-fluid -->
</div>
<!-- End Page-content -->

<!-- Date library -->
<script src="/assets/libs/moment/moment.js"></script>

<!-- apexcharts -->
<script src="/assets/libs/apexcharts/apexcharts.min.js"></script>

<!-- areacharts init -->
<script src="/assets/js/pages/apexcharts-area.init.js"></script>

<script src="/assets/js/common.js"></script>

<script>
    window.globalIntervalIds = window.globalIntervalIds || [];
    
    var charts = {};
    var statsData = [];
    var tpsSeries = [{ name: "TPS", data: [] }];
    var hitRateSeries = [{ name: "HitRate", data: [] }];
    var memorySeries = [
        { name: "Max Memory", data: [] },
        { name: "RSS", data: [] },
        { name: "Used Memory", data: [] }
    ];
    var receivedConnectionsSeries = [{ name: "Recevied Connections", data: [] }];
    var tables = [
        { 
            id: "redisAnalysis", 
            headers: [
                    { name: "time", title: "Time", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "cpu", title: "CPU", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "clients", title: "Clients", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "bclients", title: "bClients", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "mem", title: "Mem", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "rss", title: "RSS", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "keys", title: "keys", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "cps", title: "CPS", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "exp", title: "EXP", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "evt", title: "EVT", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "hitrate", title: "HitRate", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "hit", title: "HIT", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "in", title: "IN", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } },
                    { name: "out", title: "OUT", style: { headerTextAlign: "center", cellTextAlign: "center", width: "14%" } }
            ] 
        }
    ];

    // 차트 영역 생성
    function createChartCard(cardId, series) {
        var parent = document.getElementById(cardId);
        if (parent) {
            var chartElement = parent.querySelector("#area_chart_stacked");
            var yaxis = {};
    
            if (cardId === "memoryCard") {
                yaxis = {
                    min: 0,
                    labels: {
                        formatter: function (value) {
                            return getMemoryCapacityUnit(value);
                        },
                        style: {
                            colors: "#666"
                        }
                    }
                }
            } else if (cardId === "hitRateCard") {
                yaxis = {
                    min: 0,
                    max: 100,
                    labels: {
                        formatter: function (value) {
                            return value.toFixed(0)
                        },
                        style: {
                            colors: "#666"
                        }
                    }
                }
            } else {
                yaxis = {
                    min: 0,
                    labels: {
                        formatter: function (value) {
                            return value.toFixed(0) // Y축 레이블 포맷 (정수)
                        },
                        style: {
                            colors: "#666"
                        }
                    }
                }
            }
    
            // 차트
            var chartOptions = {
                chart: {
                    id: cardId,
                    type: "area",
                    height: 250,
                    toolbar: {
                        show: true,
                        tools: {
                            download: true,
                            selection: false,
                            zoom: false,
                            zoomin: false,
                            zoomout: false,
                            pan: true,
                            reset: false
                        }
                    },
                    animations: {
                        enabled: true, // 데이터 업데이트 시 부드러운 애니메이션 효과
                        easing: "linear",
                        animateGradually: {
                            enabled: false,
                        },
                        dynamicAnimation: {
                            enabled: true,
                            speed: 1100
                        }
                    }
                },
                xaxis: {
                    type: "datetime", // X축 타입을 datetime으로 설정\
                    range: 60000,
                    labels: {
                        formatter: function (val) {
                            return moment(val).format("HH:mm");
                        },
                        style: {
                            colors: "#666"
                        }
                    }
                },
                yaxis,
                series,
                dataLabels: {
                    enabled: false
                },
                stroke: {
                    curve: "smooth",
                    width: 2
                },
                fill: {
                    opacity: 0.06,
                    colors: getChartColorsArray(cardId),
                    type: "solid"
                },
                tooltip: {
                    enabled: true,
                    followCursor: true,
                    x: {
                        format: "HH:mm:ss" // 툴팁 X축 포맷 (시간과 날짜 포함)
                    }
                },
                colors: getChartColorsArray(cardId),
                legend: {
                    position: "bottom"
                },
                grid: {
                    row: {
                        colors: ["#f3f3f3", "transparent"], // 교차 행 색상
                        opacity: 0.5
                    }
                }
            }
    
            charts[cardId] = new ApexCharts(chartElement, chartOptions);
            charts[cardId].render();

            var lastX = series[0].data.length > 0 && series[0].data[series[0].data.length - 1].x;
            var optionsUpdate = {
                xaxis: { min: lastX - 60000, max: lastX }
            };
            charts[cardId].updateSeries(series);
            charts[cardId].updateOptions(optionsUpdate, false, true);
        }
    }

    // 차트 그리기
    function addDataPoint(cardId, series) {
        if (!series || series.length === 0) return;

        // charts에 데이터 추가
        var datas = series.map(elem => ({ data: [_.last(elem.data)] }));
        if (charts[cardId] && datas.length > 0) {
            charts[cardId].appendData(datas);
            var lastX = series[0].data[series[0].data.length - 1].x;

            var optionsUpdate = {
                xaxis: { min: lastX - 60000, max: lastX }
            };

            // ============================
            // TPS Card
            // ============================
            if (cardId === "tpsCard") {
                var allY = series[0].data.map(d => d.y);
                var maxY = Math.max(...allY);
                var adjustedMaxY = maxY * 1.1; // 10% 여유

                // max값에 따라 100 또는 500단위로 조정
                var step = adjustedMaxY > 500 ? 500 : 100;
                var roundedMaxY = Math.ceil(adjustedMaxY / step) * step;

                optionsUpdate.yaxis = {
                    min: 0,
                    max: roundedMaxY,
                    tickAmount: 5,
                    labels: {
                        formatter: val => val.toFixed(0)
                    }
                };

            // ============================
            // Memory Card
            // ============================
            } else if (cardId === "memoryCard") {
                var allY = series.flatMap(s => s.data.map(d => d.y));
                var maxY = Math.max(...allY);
                var adjustedMaxY = maxY * 1.1;

                // Memory 단위: MB 또는 GB 자동 변환
                optionsUpdate.yaxis = {
                    min: 0,
                    max: adjustedMaxY,
                    labels: {
                        formatter: val => {
                            return getMemoryCapacityUnit(val);
                        }
                    }
                };

            // ============================
            // HitRate Card
            // ============================
            } else if (cardId === "hitRateCard") {
                optionsUpdate.yaxis = {
                    min: 0,
                    max: 100,
                    tickAmount: 5,
                    labels: { formatter: val => val.toFixed(0) + "%" }
                };

            // ============================
            // Received Connections Card
            // ============================
            } else if (cardId === "receivedConnectionsCard") {
                var allY = series[0].data.map(d => d.y);
                var maxY = Math.max(...allY);
                var adjustedMaxY = maxY * 1.1; // 10% 여유

                // max값에 따라 100 또는 500단위로 조정
                var step = adjustedMaxY > 500 ? 500 : 100;
                var roundedMaxY = Math.ceil(adjustedMaxY / step) * step;

                optionsUpdate.yaxis = {
                    min: 0,
                    max: roundedMaxY,
                    tickAmount: 5,
                    labels: {
                        formatter: val => val.toLocaleString()
                    }
                };
            }

            charts[cardId].updateOptions(optionsUpdate, false, true);
        }
    }

    // card box 설정
    function initCard() {
        var cards = [
            { id: "tpsCard", title: "TPS" },
            { id: "hitRateCard", title: "Hit Rate" },
            { id: "memoryCard", title: "Memory" },
            { id: "receivedConnectionsCard", title: "Received Connections" },
            { id: "redisAnalysis", title: "Analysis" },
            { id: "instanceInformation", title: "Instance Information" }
        ];

        cards.forEach(elem => {
            var parent = document.getElementById(elem.id);
            var cardHeaderElement = parent.querySelector(".card-header .card-title");

            // 차트 제목
            cardHeaderElement.innerText = elem.title;
        })
    }

    // 차트 초기설정
    async function initChart() {
        await getStats();
        setTPSData();
        createChartCard("tpsCard", _.cloneDeep(tpsSeries));
        
        setHitRateData();
        createChartCard("hitRateCard", _.cloneDeep(hitRateSeries));

        setMemory()
        createChartCard("memoryCard", _.cloneDeep(memorySeries));

        setReceivedConnectionsData();
        createChartCard("receivedConnectionsCard", _.cloneDeep(receivedConnectionsSeries));
    }

    // 차트 제거 후 재생성
    function destroyChart() {
        var cardIds = ["tpsCard", "hitRateCard", "memoryCard", "receivedConnectionsCard"];

        cardIds.forEach((elem, idx) => {
            if (charts[elem]) {
                charts[elem].destroy();
                delete charts[elem];
            }

            switch (idx) {
                case 1: hitRateSeries[0].data = []; break;
                case 2: 
                    memorySeries[0].data = []; 
                    memorySeries[1].data = []; 
                    memorySeries[2].data = []; 
                    break;
                case 3: receivedConnectionsSeries[0].data = []; break;
                default: tpsSeries[0].data = [];
            }
        });

        initChart();
    }

    // TPS 차트 데이터 설정
    function setTPSData() {
        var totalPoints = 60;

        var cloneStatsData = _.cloneDeep(statsData);
        var statsSum = cloneStatsData.map(elem => {
            elem.redisInfoList = _.pick(elem.redisInfoList, ["sum"]);
            return { ...elem }
        });
        console.log("statsSum: ", statsSum);
        
        statsSum.forEach((item) => {
            var curTime = moment(item.formatedEpochTime, "YYYY-MM-DD HH:mm:ss").toDate().getTime()
            if(!_.some(tpsSeries[0].data, { x: curTime })) {
                tpsSeries[0].data.push({
                    x: curTime,
                    y: item.redisInfoList.sum.stats.instantaneousOpsPerSec
                })
            }
        });
        
        if (tpsSeries[0].data.length > totalPoints) {
            tpsSeries[0].data.shift();
            // tpsSeries[0].data = _.drop(tpsSeries[0].data, tpsSeries[0].data.length - totalPoints);
        }
    }

    // Hit Rate 차트 데이터 설정
    function setHitRateData() {
        var totalPoints = 60;

        var cloneStatsData = _.cloneDeep(statsData);
        var statsSum = cloneStatsData.map(elem => {
            elem.redisInfoList = _.pick(elem.redisInfoList, ["sum"]);
            return { ...elem }
        });

        statsSum.forEach((item, index) => {
            var curTime = moment(item.formatedEpochTime, "YYYY-MM-DD HH:mm:ss").toDate().getTime()
            if(!_.some(hitRateSeries[0].data, { x: curTime })) {
                if (index > 0) {
                    var beforeStats = statsSum[index - 1].redisInfoList.sum.stats;
                    var lastStatsSumStats = statsSum[index].redisInfoList.sum.stats;
        
                    var keyspaceHits = lastStatsSumStats.keyspaceHits - beforeStats.keyspaceHits;
                    var keyspaceMisses = lastStatsSumStats.keyspaceMisses - beforeStats.keyspaceMisses;
                    var newHitRate = keyspaceHits / (keyspaceHits + keyspaceMisses) * 100;
        
                    if (Number.isNaN(newHitRate)) {
                        newHitRate = 0;
                    }
                    hitRateSeries[0].data.push({
                        x: curTime,
                        y: newHitRate
                    })
                }
            }
        });
        
        if (hitRateSeries[0].data.length > totalPoints) {
            hitRateSeries[0].data.shift();
            // hitRateSeries[0].data = _.drop(hitRateSeries[0].data, hitRateSeries[0].data.length - totalPoints);
        }
    }

    // Memory 차트 데이터 설정
    function setMemory() {
        var totalPoints = 60;

        var cloneStatsData = _.cloneDeep(statsData);
        var statsSum = cloneStatsData.map(elem => {
            elem.redisInfoList = _.pick(elem.redisInfoList, ["sum"]);
            return { ...elem }
        });

        statsSum.forEach((item, index) => {
            var curTime = moment(item.formatedEpochTime, "YYYY-MM-DD HH:mm:ss").toDate().getTime()
            if(!_.some(memorySeries[0].data, { x: curTime })) {
                var maxmemory = item.redisInfoList.sum.memory.maxmemory ?? 0;
                memorySeries[0].data.push({
                    x: curTime,
                    y: maxmemory
                });
            }

            if(!_.some(memorySeries[1].data, { x: curTime })) {
                var usedMemoryRss = item.redisInfoList.sum.memory.usedMemoryRss ?? 0;
                memorySeries[1].data.push({
                    x: curTime,
                    y: usedMemoryRss
                });
            }
            
            if(!_.some(memorySeries[2].data, { x: curTime })) {
                var usedMemory = item.redisInfoList.sum.memory.usedMemory ?? 0;
                memorySeries[2].data.push({
                    x: curTime,
                    y: usedMemory
                });
            }
        });

        memorySeries.forEach(elem => {
            if (elem.data.length > totalPoints) {
                elem.data.shift();
                // elem.data = _.drop(elem.data, elem.data.length - totalPoints);
            }
        })
    }

    // Received Connections 차트 데이터 설정
    function setReceivedConnectionsData() {
        var totalPoints = 60;

        var cloneStatsData = _.cloneDeep(statsData);
        var statsSum = cloneStatsData.map(elem => {
            elem.redisInfoList = _.pick(elem.redisInfoList, ["sum"]);
            return { ...elem }
        });

        statsSum.forEach((item, index) => {
            var curTime = moment(item.formatedEpochTime, "YYYY-MM-DD HH:mm:ss").toDate().getTime()
            if(!_.some(receivedConnectionsSeries[0].data, { x: curTime })) {
                if (index > 0) {
                    // 1초전 stats
                    var secondsAgoStatsSumStats = statsSum[index - 1].redisInfoList.sum.stats;
                    
                    // 1초전 totalConnectionsReceived 
                    var secondsAgoConnectedReceived = secondsAgoStatsSumStats.totalConnectionsReceived;

                    // 마지막 stats 데이터
                    var lastStatsSumStats = statsSum[index].redisInfoList.sum.stats;
                    
                    // 마지막 totalConnectionsReceived
                    var lastConnectedReceived = lastStatsSumStats.totalConnectionsReceived;
                    
                    // 마지막 totalConnectionsReceived - 1초전 totalConnectionsReceived
                    var computedConnectedReceived = Math.max(lastConnectedReceived - secondsAgoConnectedReceived, 0);
                    receivedConnectionsSeries[0].data.push({
                        x: curTime,
                        y: computedConnectedReceived
                    })
                }
            }
        });
        
        if (receivedConnectionsSeries[0].data.length > totalPoints) {
            receivedConnectionsSeries[0].data.shift();
            // receivedConnectionsSeries[0].data = _.drop(receivedConnectionsSeries[0].data, receivedConnectionsSeries[0].data.length - totalPoints);
        }
    }

    // Table 설정
    function createInitTable(cardId, headers) {
        var parent = document.getElementById(cardId);
        var tableTheadTr = parent.querySelector("table thead tr");
        var tableTbody = parent.querySelector("table tbody");
        
        // Table thead 설정
        tableTheadTr.innerHTML = "";
        headers.forEach(elem => {
            var tableTh = document.createElement("th");
            tableTh.style.textAlign = elem.style.headerTextAlign;
            tableTh.innerText = elem.title;
            tableTheadTr.appendChild(tableTh);
        });
        
        // Table tbody 설정
        var tableTbodyTr = document.createElement("tr");
        var tableTd = document.createElement("td");
        tableTd.textContent = "데이터가 없습니다.";
        tableTd.style.textAlign = "center";
        tableTd.colSpan = headers.length;
        tableTbodyTr.appendChild(tableTd);

        tableTbody.innerHTML = "";
        tableTbody.appendChild(tableTbodyTr);
    }

    // Table Header 초기설정
    function initTableHeader() {
        tables.forEach(elem => {
            createInitTable(elem.id, elem.headers);
        });
    }

    // Redis stat 데이터 설정
    function setRedisStat() {
        var cloneStatsData = _.cloneDeep(statsData);
        var statsSum = cloneStatsData.map(elem => {
            elem.redisInfoList = _.pick(elem.redisInfoList, ["sum"]);
            return { ...elem }
        });

        var redisStatDatas = [];
        var totalRows = 10;
        statsSum.forEach(elem => {
            var hitRate = 0
            if (elem.redisInfoList.sum.stats.keyspaceHits + elem.redisInfoList.sum.stats.keyspaceMisses > 0) {
                hitRate = elem.redisInfoList.sum.stats.keyspaceHits / (elem.redisInfoList.sum.stats.keyspaceHits + elem.redisInfoList.sum.stats.keyspaceMisses);
            }
            var newRow = {
                Time: moment(elem.formatedEpochTime).format("HH:mm:ss"),
                CPU: (Number(elem.redisInfoList.sum.cpu.usedCpuSys) + Number(elem.redisInfoList.sum.cpu.usedCpuUser)).toFixed(2) ?? "-",
                Clients: elem.redisInfoList.sum.clients.connectedClients.toLocaleString() ?? "-",
                bClients: elem.redisInfoList.sum.clients.blockedClients.toLocaleString() ?? "-",
                Mem: getMemoryCapacityUnit(elem.redisInfoList.sum.memory.usedMemory) ?? "-",
                RSS: getMemoryCapacityUnit(elem.redisInfoList.sum.memory.usedMemoryRss) ?? "-",
                keys: elem.redisInfoList.sum.keyspace["0"].keys.toLocaleString() ?? "-",
                CPS: elem.redisInfoList.sum.stats.instantaneousOpsPerSec.toLocaleString() ?? "-",
                EXP: elem.redisInfoList.sum.stats.expiredKeys.toLocaleString() ?? "-",
                EVT: elem.redisInfoList.sum.stats.evictedKeys.toLocaleString() ?? "-",
                HitRate: (hitRate * 100).toFixed(0) + "%" ?? "-",
                HIT: elem.redisInfoList.sum.stats.keyspaceHits.toLocaleString() ?? "-",
                IN: elem.redisInfoList.sum.stats.instantaneousInputKbps.toFixed(2) ?? "-",
                OUT: elem.redisInfoList.sum.stats.instantaneousOutputKbps.toFixed(2) ?? "-"
            }
            redisStatDatas.push(newRow)
            if (redisStatDatas.length > totalRows) {
                redisStatDatas.shift();
            }

            var cardId = "redisAnalysis";
            var parent = document.getElementById(cardId);
            if (parent) {
                var tableTbody = parent.querySelector("table tbody");
                
                tableTbody.innerHTML = "";
                if (cloneStatsData.length > 0) {
                    redisStatDatas.forEach(elem => {
                        var tableTr = document.createElement("tr");
                        var keys = Object.keys(elem);
                        keys.forEach(key => {
                            var tableTd = document.createElement("td");
                            tableTd.style.textAlign = "center";
                            tableTd.innerText = elem[key];
                            tableTr.appendChild(tableTd);
                        })
                        tableTbody.appendChild(tableTr);
                    });
                } else {
                    var tableTr = document.createElement("tr");
                    var tableTd = document.createElement("td");
                    tableTd.textContent = "데이터가 없습니다.";
                    tableTd.style.textAlign = "center";
                    tableTd.colSpan = tableInfo.headers.length;
                    tableTr.appendChild(tableTd);
    
                    tableTbody.innerHTML = "";
                    tableTbody.appendChild(tableTr);
                }
            }
        });
    }

    // Redis 정보 조회
    async function getStats() {
        var response = await fetch("/v1/redis/stats");
        if (!response.ok) throw new Error("HTTP " + res.status);

        statsData = await response.json();
    }

    // Instance Information 데이터 설정
    function setInstanceInfo() {
        console.log("setInstanceInfo() - statsData: ", statsData);
        var instanceInfoData = [];
        var redisList = {};
        var instanceInfoTableContent = ['version', 'mode', 'role', 'uptime', 'master_info', 'slave_info', 'aof_enable', 'hz', 'rdb_last_save_time', 'memory_policy', 'connected_clients', 'pid', 'maxclients', 'blocked_clients', 'mem_fragmentation_ratio'];
        var redisInfoHeaders = [];
        var redisHost = '';
        var dataObj = Object.keys(statsData);

        var lastStats = _.last(statsData).redisInfoList;
        var statsRedisServer = _.omit(lastStats, ["sum"]);

        // header 설정
        redisInfoHeaders = _.sortBy(_.keys(statsRedisServer), str => {
            var [ip, port] = str.split(":");
            var ipParts = ip.split(".").map(Number);
            return _.padStart(port, 5, "0") + ipParts.map(n => _.padStart(n, 3, "0")).join("");
        })
        redisInfoHeaders.unshift("information");

        // row datas 설정
        for (var i = 0; i < instanceInfoTableContent.length; i++) {
            var dataRow = {}
            redisInfoHeaders.forEach(elem => {
                if (elem === "information") {
                    dataRow[elem] = instanceInfoTableContent[i];
                } else {
                    dataRow[elem] = "-";
                }
            });
            instanceInfoData.push(dataRow);
        }
        
        const keys = Object.getOwnPropertyNames(statsRedisServer);
        instanceInfoData.forEach(elem => {
            var ports = Object.keys(elem);
            ports.forEach(port => {
                if (port !== "information") {
                    var key = _.filter(keys, value => _.includes(value, port))[0];
                    var redisInfo = lastStats[key];

                    instanceInfoTableContent.some(instance => {
                        if (elem["information"] == "version") {
                            elem[port] = redisInfo.server.redisVersion;
                            return true;
                        } else if (elem["information"] == "mode") {
                            elem[port] = redisInfo.server.redisMode;
                            return true;
                        } else if (elem["information"] == "role") {
                            elem[port] = redisInfo.replication.role;
                            return true;
                        } else if (elem["information"] == "uptime") {
                            var duration = moment.duration(redisInfo.server.uptimeInSeconds, "seconds");
                            elem[port] = duration.humanize();
                            return true;
                        } else if (elem["information"] == "master_info") {
                            elem[port] = redisInfo.server.host + ":" + redisInfo.server.tcpPort;
                            return true;
                        } else if (elem["information"] == "slave_info") {
                            var slaveInfo = redisInfo.replication.masterHost + ":" + redisInfo.replication.masterPort;
                            if (redisInfo.replication.masterHost === null && redisInfo.replication.masterPort === 0) {
                                slaveInfo = "연결 없음";
                            }
                            elem[port] = slaveInfo;
                            return true;
                        } else if (elem["information"] == "aof_enable") {
                            elem[port] = redisInfo.persistence.aofEnabled;
                            return true;
                        } else if (elem["information"] == "hz") {
                            elem[port] = redisInfo.server.hz;
                            return true;
                        } else if (elem["information"] == "rdb_last_save_time") {
                            elem[port] = moment.unix(redisInfo.persistence.rdbLastSaveTime).format("YYYY-MM-DD HH:mm:ss");
                            return true;
                        } else if (elem["information"] == "memory_policy") {
                            elem[port] = redisInfo.memory.maxmemoryPolicy;
                            return true;
                        } else if (elem["information"] == "connected_clients") {
                            elem[port] = redisInfo.clients.connectedClients.toLocaleString();
                            return true;
                        } else if (elem["information"] == "pid") {
                            elem[port] = redisInfo.server.processId.toLocaleString();
                            return true;
                        } else if (elem["information"] == "maxclients") {
                            elem[port] = redisInfo.clients.maxclients.toLocaleString();
                            return true;
                        } else if (elem["information"] == "blocked_clients") {
                            elem[port] = redisInfo.clients.blockedClients.toLocaleString();
                            return true;
                        } else if (elem["information"] == "mem_fragmentation_ratio") {
                            elem[port] = redisInfo.memory.memFragmentationRatio;
                            return true;
                        }
                    });
                }
            })
        });

        // 테이블 그리기
        var cardId = "instanceInformation";
        var parent = document.getElementById(cardId);
        if (parent) {
            var cardBody = parent.querySelector(".card-body");
            cardBody.innerHTML = "";
            cardBody.appendChild(createTable(redisInfoHeaders, instanceInfoData, "table table-bordered dt-responsive nowrap table-striped align-middle", { width: "100%" }));
        }
    }

    async function intervalInit() {
        await getStats();
        setTPSData();
        addDataPoint("tpsCard", tpsSeries)

        setHitRateData();
        addDataPoint("hitRateCard", hitRateSeries);
        
        setMemory();
        addDataPoint("memoryCard", memorySeries);
        
        setReceivedConnectionsData();
        addDataPoint("receivedConnectionsCard", receivedConnectionsSeries);

        setRedisStat();
        setInstanceInfo();
    }

    function clearIntervalIds() {
        if (window.globalIntervalIds.length > 0) {
            window.globalIntervalIds.forEach(id => clearInterval(id));
            window.globalIntervalIds = [];
        }
    }

    // Life Cycle START
    var hiddenAt = null; // 최소화 시작 시간 기록
    window.pageHooks = window.pageHooks || {};
    window.pageHooks["pages-armedis-realtime-stats.html"] = {
        // 페이지가 로드 됐을 때
        onLoad: function () {
            initCard();
            initChart();
            initTableHeader();
            
            // 기존 interval 모두 제거
            clearIntervalIds();
            var intervalId = setInterval(intervalInit, 1000);
            window.globalIntervalIds.push(intervalId);
        },
        // 페이지를 떠날 때
        onUnload: function () {
            clearIntervalIds();
        }
    };

    document.addEventListener("visibilitychange", function() {
        if (document.hidden) {
            hiddenAt = Date.now();
        } else {
            var hiddenDuration = (Date.now() - hiddenAt) / 1000;
            console.log(`브라우저가 ${hiddenDuration}초 동안 비활성화됨`);

            // 특정 시간 이상일 때만 실행
            if (hiddenDuration > 60) {
                console.log("차트 재랜더링!");
                
                // 차트 제거 후 재랜더링
                destroyChart();
            }
        }
    });
    // Life Cycle END
</script>